// Generated by CoffeeScript 1.6.2
/*
# Name:    jquery.taggingAutocomplete.js
# By:      Dan Pozzie
# Updated: 18/5/2013
# Purpose: Hook JQuery UI Autocomplete for tagging usages in a
#          coffeescript environment, while moving the token-input
#          aspect from civicrm's core jquery.tokeninput.js. Instead
#          of hooking and modifying it out a lot of additional
#          functionality that isn't in tokeninput's scope, leverage
#          jquery ui's AC to do the following:
#
*/


(function() {
  (function($, window, document) {
    var $this, acSettings, methods, _cache, _flag, _internals, _settings;

    $this = void 0;
    _settings = {
      jqDataReference: "",
      hintText: "Type in a partial or complete name of an tag or keyword.",
      theme: "JSTree",
      ajaxLocation: "",
      textBoxLocation: "#JSTree-ac",
      menuElement: ".JSTree-me",
      source: "",
      minLength: 3,
      delay: 100
    };
    _flag = false;
    _cache = {};
    acSettings = methods = {
      init: function(options) {
        $this = $(this);
        $.extend(_settings, options || {});
        _internals.enableAC();
        return $this;
      },
      kill: function(note) {
        console.log("Killed with: " + note);
        return $this;
      }
    };
    _internals = {
      enableAC: function() {
        this.turnDataLocation();
        this.selectedItem = null;
        this.element = $("" + _settings.textBoxLocation);
        this.menuelement = $("" + _settings.menuElement);
        return this.checkValue();
      },
      checkValue: function() {
        var _this = this;

        return this.element.on("keydown", function(event) {
          _this.query = _this.element.val();
          return _this.checkKeycodes(event);
        });
      },
      checkKeycodes: function(event) {
        var _this = this;

        clearTimeout(this.searching);
        return this.searching = setTimeout((function() {
          if (_this.query !== _this.element.val()) {
            return _this.search(null, event);
          }
        }), _settings.delay);
      },
      search: function(value, event) {
        if (value != null) {
          value = value;
        } else {
          value = this.element.val();
        }
        console.log(value, this.element.val());
        this.term = this.element.val();
        if (value.length < _settings.minLength) {
          return event;
        }
        console.log("value: " + value.length);
        return console.log("minLength: " + _settings.minLength);
      },
      _search: function(value) {
        this.pending++;
        return this.source({
          term: value
        });
      },
      turnDataLocation: function() {
        if (_settings.jqDataReference != null) {
          return _settings.source = cj(_settings.jqDataReference).data("autocomplete");
        } else {
          return methods.kill("No Data Location");
        }
      },
      toggleFlag: function() {
        return _flag = !_flag;
      },
      computeSomething: function(state, flag) {
        return flag != null ? flag : {
          state: "No, that's not right."
        };
      }
    };
    return $.fn.tagACInput = function(method) {
      if (methods[method]) {
        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
      } else if (typeof method === "object" || !method) {
        return methods.init.apply(this, arguments);
      } else {
        return $.error("Method " + method + " does not exist on jquery.tagACInput");
      }
    };
  })(cj, window, document);

}).call(this);
